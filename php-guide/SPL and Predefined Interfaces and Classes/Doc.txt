Cсылка на документацию http://www.php.net/manual/ru/book.spl.php

Особенности использования расширения.
-------------------------------------

Closure(класс) реализует возможность создания анонимных функций через магический метод __invoke(). Архиважный класс!!! 
    Анонимные функции - это объекты класса Closure, к которым можно обращаться как к фуекциям благодаря встроенному в Closure методу __invoke().
    Но можно к анонимным функциям обращаться и напрямую, как к объектам $anonim->__invoke($argum).

                    Интерфейсы-разные:
                    ------------------

ArrayAccess реализует возможность работы с объектом как с массивом, что не представляет интереса, но он
    является интерфейсом класса ArrayIterator и делегирует ему свои возможности.

Serializable реализует индивидуальную сериализацию объектов. Позволяет детально настраивать сериализацию в классах 
    (в первую очередь при наследовании и приватных свойствах) в отличие от __sleep() и __wakeup().  

SplObserver, SplSubject  предназначены для реализации шаблона проектирования Наблюдатель (Observer).


                    Интерфейсы-итераторы:
                    ---------------------
Iterator и его DI-Aggregate IteratorAggregate (оба унаследованы от Travesable) позволяют
    тонко вмешаться в переборы(итерации) с помощью циклов foreach и создавать в них свою логику.

OuterIterator    - расширение интерфейса Iterator, которое добавляет возможность работы с внутреним итератором. 

SeekableIterator - расширение интерфейса Iterator, которое добавляет возможность перемещения итератора к заданной позиции.

RecursiveIterato - расширение интерфейса Iterator, которое добавляет возможность детальной работы с многомерными массивами.

                    
            Классы-итераторы (реализация интерфейсов-итераторов):
            ----------------------------------------------------
Порождающие итераторы:
--------------------------------------------------------------------------------

EmptyIterator - создаёт объект пустой итератор. Он создаёт пустую переменную требуемого типа - итератор класса Iterator.
    Это аналогично пустому массиву $arr = array() или пустому классу $obj = new stdClass().
    Это может пригодиться для каких-то проверок типа или наследования.

ArrayIterator - позволяет работать с массивом как с объектом-итератором. Создаёт контейнер-объект (итератор) для передаваемого ему одномерного! массива, через методы которого 
    предоставляется хороший инструментарий работы с переданным массивом в циклах foreach (и вне циклов). Очень важный класс!!!.
    Он используется итерирующими итераторами типа IteratorIterator (его расширениями) для более детальной итерации. 

RecursiveArrayIterator - является расширением ArrayIterator (наследует все его методы) для работы с многомерными массивами. 
    Он используется итерирующими итераторами типа IteratorIterator (его расширениями) и RecursiveIteratorIterator для более детальной итерации.
    Наравне с ArrayIterator очень полезный класс (ArrayIterator - для одномерных, а RecursiveArrayIterator - многомерных массивов)

ArrayObject - позволяет работать с массивом как с объектом. По своему функционалу и работе он аналогичен классу ArrayIterator, но без итерирующих методов.
    Для более детальной итерации вкладывать его в ArrayIterator с последующим использованием итерирующих итераторов типа IteratorIterator (его расширений).
    Настоятельно рекомендуется использовать его или ArrayIterator (для многомерных - RecursiveArrayIterator) для работы с массивами.

 ---- Порождающие итераторы для работы с файловой системой (см. папку File Handling):
 
SplFileInfo - это главный информационный класс о файле. От него расширяются все остальные файлавые классы.
    Если требуются методы работы над файлом как над объектом (чтение, запись и т.д.),
    то надо создать объект с помощью метода SplFileInfo::openFile(), но лучше создавать объект напрямую через new SplFileObject().

SplFileObject - предоставляет объектно-ориентированный интерфейс для работы с файлом. Он работает с файлом построчно.
    Он имеет полный функционал работы с файлами и наследует информационный интерфейс от родителя SplFileInfo.
    Кроме того, он имеет переопределённые методы интерфейсов Iterator, что делает  
    возможным работу с ним как с итератором. По сути он представляет собой ArrayIterator, который 
    может работать с итерирующими итераторами.

DirectoryIterator - предоставляет простой интерфейс для просмотра содержимого каталогов файловой системы (для работы с директорией).  
    Он унаследовал все методы SplFileInfo, но применительно к директории.   
    Благодаря наследованию от Iterator, DirectoryIterator представляет собой полноценный итератор (подобно ArrayIterator), но 
    применительно к файлам директории как элементам массива. И ему доступны все расширения одномерный итерирующих итераторов.

GlobIterator - ищет все пути относительно глобального, совпадающие с шаблоном pattern.
    формирует на основе найденных результатов итератор типа ArrayIterator согласно правилам, указанным в флагах.

FilesystemIterator - итератор файловой системы. Он расширяет итератор директории DirectoryIteratory, добавляя
    возможность более тонко настроить методы key()=>current() - возвращение нужного элемента итерации в зависимости от флага (DirectoryIterator возвращал
    только текущий элемент итератора DirectoryIterator). В остальном это полный аналог итератора DirectoryIteratory

RecursiveDirectoryIterator - предоставляет интерфейс для рекурсивного перебора каталогов файловой системы. В отличие от DirectoryIterator он 
    вобрал в себя методы тонкой работы класса FilesystemIterator по возвращению требуемого результата от key()=>current() в зависимости от флага. 
    RecursiveDirectoryIterator - рекурсивный итератор директории по аналогии с RecursiveArrayIterator и работать с ним надо соответ-
    ствующими рекурсивными итерирующими итераторами (напр. RecursiveIteratorIterator)

--------------------------------------------------------------------------------
Итерирующие итераторы или обёртки итераторов (работают с переданным итератором):
--------------------------------------------------------------------------------

IteratorIterator - итерирует объекты, созданные порождающими одномерными итераторами (ArrayIterator). 
    Этот итерирующий итератор - обёртка одномерных итераторов.
    Имеет реализованный функционал интерфейса Iterator плюс доступ для расширения класса.
    Это скорее заготовка для расширения итератора, потому что он сам по себе бесполезен.
    Но если его расширять благодаря встроенному доступу, то можно создать свой класс, имеющий стандартный встроенный набор итератора IteratorIterator и 
    набор своих методов. На основе его соозданы важные расширения FilterIterator, LimitIterator, InfiniteIterator, AppendIterator и т.д.

InfiniteIterator - представляет собой бесконечный итератор IteratorIterator. 
    Передаваемый в конструктор итератор будет бесконечно перезапускаться в foreach.
    Имеет специфическое применение.

NoRewindIterator - это итератор IteratorIterator, который не может быть перемотан. 
    Он как бы замораживает позицию итерации. Имеет специфическое применение.

FilterIterator - этот абстрактный итератор фильтрует нежелательные значения одномерных итераторов. Он расширяет IteratorIterator.
    Этот класс следует расширить для реализации пользовательских фильтров итератора. Очень полезный класс.

CallbackFilterIterator - это реализация абстрактного класса FilterIterator с использованием внешней Callback-функции в качестве фильтра.
    Позволяет разделить фильтрацию на два класса: собственно класс фильтрации CallbackFilterIterator и класс-набор фильтров, методы которого будут
    возвращать фильтры (сallback-функции класса Сlosure) в CallbackFilterIterator в зависимости от внешних условий. 
    !!! Позволяет применять пользовательскую библиотеку фильтров к фильтрации итераторов через CallbackFilterIterator.

LimitIterator - позволяет сделать перебор ограниченного количества элементов по заданным параметрам в переданном ему итераторе. 
    Он расширяет IteratorIterator. Очень полезный класс.

RegexIterator - это реализация(расширение) абстрактного класса FilterIterator.
    Этот итератор может быть использован для фильтрации другого одномерного итератора на основе регулярных выражений.

AppendIterator - итератор, который выполняет несколько итераторов один за другим последовательно.
    Он как бы склеивает итераторы с помощью метода добавления итератора append(Iterator $iterator). К концу одного - другой (последовательно).
    Это ещё одно полезное расширение класса IteratorIterator.

MultipleIterator - итератор, который последовательно перебирает все подключенные итераторы, 
    совершая параллельную склейку итераторов. AppendIterator и MultipleIterator - итераторы объединения,
    последовательного и параллельного соответсвенно.

--- Рекурсивные итерирующие итераторы

RecursiveIteratorIterator - может быть использован для перебора рекурсивных итераторов класса RecursiveArrayIterator().		
    Даёт полный набор инструментов для работы с многомерными итераторами через циклы foreach. 
    !!! В связке new RecursiveIteratorIterator(new RecursiveArrayIterator($array)) предоставляет абсолютную гибкость работы с многомерным массивом $array

RecursiveFilterIterator - Этот абстрактный итератор отфильтровывает нежелательные значения для многомерных итераторов тииа RecursiveIterator.
    Этот класс следует расширять для реализации пользовательских фильтров.

ParentIterator - Это реализация(расширение) абстрактного класса RecursiveFilterIterator.
    Он показывает (фильтрует) только те элементы, которые имеют потомков. 

RecursiveRegexIterator - Этот рекурсивный итератор может фильтровать другой рекурсивный итератор RecursiveIterator с помощью регулярных выражений. 

RecursiveCallbackFilterIterator - это расширение CallbackFilterIterator для фильтрации многомерных итераторов 
    (в него передаётся многомерный итератор класса RecursiveIterator).     

