<?php
/*
Generator implements Iterator {

	private __construct() - нельзя создать объект этого класса с помощью new
	mixed throw ( Exception $exception ) - выбрасывает исключение в генератор если идёт обращение к закрытому генератору	
	mixed send ( mixed $value )	- отправляет заданное значение генератору  и перезапускает генератор (next()).
	void __wakeup ( void ) - сериализует callback
	
  Переопределённые методы от Iterator	
	void rewind ( void )    - запуск итератора		
	bool valid ( void )	    - проверяет закрыт ли генератор
	mixed key ( void )		- возвращает yield-ключ
	mixed current ( void )	- возвращает yield-значение
	void next ( void )		- запуск следующего прохода генератора	
}

Генератор внешне похож на обычную функцию, и обладает некоторым сходством с замыканиями. 
При первом вызове в контексте итератора (например, в цикле foreach), генератор возвращает объекта класса Generator, который, в свою очередь, реализует интерфейс Iterator. 
Значения для итерации генерируются в реальном времени, что избавляет от необходимости загружать весь набор данных в память, получая значения по мере необходимости. 
Из этого следует, что итерация по результату осуществляется так же, как по массиву, не считая некоторых отличий:
    
	-итерация направлена только вперед, нельзя вернуться к предыдущему значению или к началу. Вызов метода rewind() выбросит исключение;
    -скорость выполнения итерации ниже, чем в случае с предварительно заполненным массивом, т.к. для получения следующего значения генератор выполняет какие-то действия;
    -крайне эффективное использование памяти.

Невозможность возврата значения через оператор return – это одно из основных отличий генератора от других функций или замыканий. 
Вместо него для передачи значения из генератора применяется ключевое слово yield (например, yield $dog). 
Указание значения после return приведет к синтаксической ошибке, а применение пустого оператора – простой способ остановить работу генератора.
Оператор yield приостанавливает выполнение и возвращает текущее значение в контекст структуры, использующей генератор. 
Эта структура может отправить информацию обратно в генератор во время его выполнения с помощью метода send (например, $generator->send(-1);).

Основные преимущества генераторов можно свести к простоте реализации, повышению читаемости кода, повышению эффективности расходования памяти.
Вообще говоря, стоит применять генераторы всегда, когда не требуется повторно обходить набор данных с начала или просматривать его в обратном направлении. 
С другой стороны, если не учитывать расходование памяти, обход обычного массива(без yield) выполняется значительно быстрее.

!!! Для понимания работы generators смотреть файл Generators.php;
*/

//Генераторы — ОЧЕНЬ мощная штука. Они позволяют очень сильно упростить код. 
//Подумайте только, вы можете написать функцию для диапазона чисел в одну строчку кода:
function xrange( $min, $max ) {
    for ($i = $min; $i <= $max; $i++) yield $i;
}

foreach (xrange(0, 10) as $v) echo $v.' / ';


///////////////// Пример с throw 
function gen() {
    echo "Foo<br>";
    try {
        yield;
    } catch (Exception $e) {
        echo "Exception: {$e->getMessage()}<br>";
    }
    echo "Bar<br>";
}
 
$gen = gen();
$gen->rewind();
$gen->throw(new Exception('Test'));

//Foo
//Exception: Test
//Bar

// пример с send (обратная отправка данных генератору)
function printer() {
    while (true) {
        $string = yield;
        echo $string;
    }
}

$printer = printer();
$printer->send('Hello world!'); // Hello world!
$printer->send('Bye world!');	// Bye world!

