
Паттерны поведения рассматривают вопросы о связях между объектами и распределением обязанностей между ними. 
Для этого могут использоваться механизмы, основанные как на наследовании, так и на композиции.


Chain of Responsibility - позволяет обработать запрос нескольким объектам-получателям. 
    Получатели связываются в цепочку, и запрос передается по цепочке, пока не будет обработан каким-то объектом. Паттерн Chain of Responsibility позволяет также избежать жесткой зависимости между отправителем запроса и его получателями.

Command - преобразовывает запрос на выполнение действия в отдельный объект-команду. 
    Это придает системе гибкость: позволяет осуществлять динамическую замену команд, использовать сложные составные команды, осуществлять отмену операций.

Iterator - предоставляет механизм обхода элементов составных объектов (коллекций) не раскрывая их внутреннего представления.

Interpreter - предназначен для решения повторяющихся задач, которые можно описать некоторым  языком. 
    Для этого паттерн Interpreter описывает решаемую задачу в виде предложений этого языка, а затем интерпретирует их.

Mediator - инкапсулирует взаимодействие совокупности объектов в отдельный объект-посредник. 
    Уменьшает степень связанности взаимодействующих объектов - им не нужно хранить ссылки друг на друга.

Memento - получает и сохраняет за пределами объекта его внутреннее состояние так, чтобы позже можно было восстановить объект в таком же состоянии.

Observer - определяет зависимость "один-ко-многим" между объектами так, что при изменении состояния одного объекта все зависящие от него объекты уведомляются и обновляются автоматически.

State - позволяет объекту изменять свое поведение в зависимости от внутреннего состояния. 
    Создается впечатление, что объект изменил свой класс. Паттерн State является объектно-ориентированной реализацией конечного автомата.

Strategy - Если поведение системы настраивается согласно одному из некоторого множества алгоритму, 
    то применение паттерна Strategy переносит семейство алгоритмов в отдельную иерархию классов, что позволяет заменять один алгоритм другим в ходе выполнения программы. Кроме того, такую систему проще расширять и поддерживать.

Visitor - определяет операцию, выполняемую на каждом элементе из некоторой структуры без изменения классов этих объектов.