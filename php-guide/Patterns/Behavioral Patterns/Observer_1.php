<?php
/*
 *  Observer избегает связанность между компонентами. 
 * Один объект делает себя наблюдаемым, добавляя метод, который позволяет другому объекту, наблюдателю, себя зарегистрировать.
 * Когда наблюдаемый объект изменяется, он посылает уведомление зарегистрированным наблюдателям. 
 * Что происходит после получения уведомления с наблюдателем, не зависит от наблюдаемого объекта.
 * В результате получаем способ общения между объектами без необходимости понимания, зачем.
 * 
 *   Суть: наблюдаемый объект (Список пользователей) живёт своей жизнью и не видит что происходит в наблюдателе (логгере), 
 * при этом наблюдатель (логгер) следит за определённым действием наблюдаемого (добавление пользователя)
 * При определённом действии наблюдаемого объекта (запуске метода добавления пользователя) автоматом совершается действие наблюдателя (запуск метода вывод лог-сообщения). 
 * Важно понимать, что UserList не знает, что логгер собирается сделать. Может быть один или несколько наблюдателей, которые будут делать что-то другое. 
 * К примеру, можно сделать наблюдателя, который будет посылать некоторое сообщение новому пользователю, приветствуя вновь прибывшего.
 * Ценность такого подхода — в том, что UserList ничего не знает об объектах, зависимых от него; он концентрируется на управлении списком пользователей.
 */

////////////////////////////////////////////////////////////////////////////////////////////////////
// Эскиз наблюдаемого класа с обязательным методом-добавления объекта наблюдателя $observer
interface Observable {
    function attach ( Observer $observer ); // добавление наблюдателя
    function detach ( Observer $observer ); // удаление наблюдателя
}

// Наблюдаемый класс
class UserList implements Observable {   
    private $_observers;          // здесь будет объект-наблюдатель 
    public $userlist = array();   // список пользователей

    // метод добавления/регистрации объекта-наблюдателя
    public function attach ( Observer $observer ) {
        $this->_observers = $observer;
    }
    // метод удаления объекта-наблюдателя
    public function detach ( Observer $observer ) {
        $this->_observers = null;
    }
    // метод, при исполнении которого вызывается метод наблюдателя, который использует данные наблюдаемого
    // при добавленн юзера в список юзеров, объект-наблюдатель выводит сообщение
    public function addUser ($name) {
        $this->userlist[] = $name;
        // передаём наблюдаемый объкт в метод наблюдателя
        $this->_observers->onChanged($this);
    } 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Эскиз класcа-наблюдателя с обязательным методом, который будет запускаться при вызове определённого метода наблюдаемого-объекта
interface Observer {
    function onChanged ($obj);
}

// класc-наблюдатель
class UserListLogger implements Observer {
    // метод наблюдателя, который будет вызываться при добавлении пользователя в наблюдаемый объект
    public function onChanged ($obj){
        $count_users = count($obj->userlist);     // считаем пользователей
        $last_user = end($obj->userlist);         // выбираем последнего пользователя
        echo "Пользователь $count_users - $last_user <br>";
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
$ul = new UserList();
// добавляем/регистрируем наблюдателя в объекте
$ul->attach (new UserListLogger());
// добавляем пользователя - тем саммым одновременно запускаем соответствующий метод наблюдателяo nChanged($obj), который выводит сообщение
$ul->addUser ("Jack");
$ul->addUser ("Alex");
$ul->addUser ("John");