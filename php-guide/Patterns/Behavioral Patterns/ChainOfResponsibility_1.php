<?php
/*
Паттерн Chain of Responsibility связывает в цепочку объекты-получатели, а затем передает запрос-сообщение от одного объекта к другому до тех пор, пока не достигнет объекта, способного его обработать. 
Число и типы объектов-обработчиков заранее неизвестны, они могут настраиваться динамически. 
Механизм связывания в цепочку использует рекурсивную композицию, что позволяет использовать неограниченное число обработчиков.
Паттерн Chain of Responsibility упрощает взаимосвязи между объектами: 
	- Вместо хранения ссылок на всех кандидатов-получателей запроса, каждый отправитель хранит единственную ссылку на начало цепочки, а каждый получатель имеет единственную ссылку на своего преемника - последующий элемент в цепочке.
Убедитесь, что система корректно "отлавливает" случаи необработанных запросов.
Не используйте паттерн Chain of Responsibility, когда каждый запрос обрабатывается только одним обработчиком, или когда клиент знает, какой именно объект должен обработать его запрос.
 
Использование паттерна Chain of Responsibility
    - Базовый класс имеет указатель на "следующий обработчик".
    - Каждый производный класс реализует свой вклад в обработку запроса.
    - Если запрос должен быть "передан дальше", то производный класс "вызывает" базовый класс, который с помощью указателя делегирует запрос далее.
    - Клиент (или третья сторона) создает цепочку получателей (которая может иметь ссылку с последнего узла на корневой узел).
    - Клиент передает каждый запрос в начало цепочки.
    - Рекурсивное делегирование создает иллюзию волшебства.
 
Реализация паттерна Chain of Responsibility по шагам
    1.Создайте указатель на следующий обработчик next в базовом классе.
    2.Метод handle() базового класса всегда делегирует запрос следующему объекту.
    3.Если производные классы не могут обработать запрос, они делегируют его базовому классу.
*/		
abstract class Base {
	// 1. Указатель "next" в базовом классе на следующий в цепочке объект
	protected $next;
	function setNext( Base $handler ) {
		$this->next = $handler;
	}
	// передача звена-объекта в конец цепочки
	function add( Base $handler ) {
		if ( !empty($this->next) ) $this->next->add($handler);
        else $this->next = $handler;
	}
	// 2. Метод базового класса, делегирующий запрос next-объекту
	function handle( $i ) {
        $this->next->handle($i);
    }
}
class Handler1 extends Base {
	// 3. 3 из 4 запросов не обрабатывает и передаёт следующему в цепочке объекту
	function handle( $i ) {
        if ( rand() % 3 ) {
			echo "Handler1 passsed $i ";
            parent::handle($i); 
		} else
			echo "Handler1 handled $i ";
    }
}
class Handler2 extends Base {
	// 3. 3 из 4 запросов не обрабатывает и передаёт следующему в цепочке объекту
	function handle( $i ) {
        if ( rand() % 3 ) {
			echo "Handler2 passsed $i ";
            parent::handle($i); 
		} else
			echo "Handler2 handled $i ";
    }
}
class Handler3 extends Base {
	// 3. 3 из 4 запросов не обрабатывает и передаёт следующему в цепочке объекту
	function handle( $i ) {
        if ( rand() % 3 ) {
			echo "Handler3 passsed $i ";
            parent::handle($i); 
		} else
			echo "Handler3 handled $i ";
    }
}

$hahdler1 = new Handler1();
$handler2 = new Handler2();
$handler3 = new Handler3();

// Делаем цепочку последовательносвязанных объектов
$hahdler1->add( $handler2 ); 
$hahdler1->add( $handler3 ); // пересылается в $hahdler2->add( $handler3 )
$handler3->setNext($hahdler1);

for ( $i = 1; $i < 10; $i++ ) {
	// вызов последовательного метода: если он не может обработать входные данные (арг $i), он передаёт следующему в цепочке объекту
    $hahdler1->handle($i);
    echo '<br>';
}

/*
Вывод программы:
H1 passsed 1  H2 passsed 1  H3 passsed 1  H1 passsed 1  H2 handled 1
H1 handled 2
H1 handled 3
H1 passsed 4  H2 passsed 4  H3 handled 4
H1 passsed 5  H2 handled 5
H1 passsed 6  H2 passsed 6  H3 passsed 6  H1 handled 6
H1 passsed 7  H2 passsed 7  H3 passsed 7  H1 passsed 7  H2 handled 7
H1 handled 8   
H1 passsed 9  H2 passsed 9  H3 handled 9
 */