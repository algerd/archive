<?php
/*
  Builder следует логике последовательного создания объекта, выделяя в ней 3 функциональные части по принципу строительства объекта из реальной жизни:
    - есть класс - чертёж объекта. Он состоит из свойств и методов работы с ними.
    - eсть строитель (Builder), обеспечивающий весь функционал по созданию объекта и наполнению его свойствами - фактически это Factory Method или для семейств Abstract Factory
    - есть директор (Director), который запускает создание объекта и наполнение его свойствами и возвращает построенный объект.
  Благодаря такому разделению можно создать несколько разных билдеров для класса, которые наделят объекты одного класса разными свойствами.
  Мой пример чуть ли не дословно покажет суть этого шаблона:
  Есть чертёж магазина - в нём указаны, что он иметь стеллажи, кассы и другую инфрострутура для продажи. Но не указано что и как продавать.
  Есть строители - они строят магазин по чертежу и наполняет его товарами и создают дополнительный функционал для торговли (упаковка товара, реклама и т.д.) в зависимости от требований директора и клиента.
  Есть директор - он начинает строительство магазина (отдаёт распоряжение строителям) в зависимости от требований клиента и передаёт клиенту построенный магазин.
  Есть клиент - заказывает какой магазин он хочет получить. В нашем случае клиент - это исполнительный код, запускающий директора с передачей ему требований в виде нового объекта или какой-то метки.
  И таким образом, несмотря на один чертёж магазина, можно построить множество функционально разных магазинов. 
  Это подобно наследованию, но выполненого с помощью Composition (DI)
 */
//////////////////////////  Pizza - Чертёж строительства ///////////////////////////////////////////////////////////////
// Это чертёж объекта, который будет строиться билдерами - классами от Builder
class Pizza {
    private $_pastry = "";
    private $_sauce = "";
    private $_garniture = "";
    public function setPastry($pastry) {
        $this->_pastry = $pastry;
    }
    public function setSauce($sauce) {
        $this->_sauce = $sauce;
    }
    public function setGarniture($garniture) {
        $this->_garniture = $garniture;
    }
}
 
//////////////////////////////////// Builder - Абстрактный строитель ///////////////////////////////////////////////////
// Строит объект класса Pizza (повар печёт пиццу), и указывает каким базовым функционалом должны обладать строители - билдеры (что должна содержать пицца)
abstract class BuilderPizza {
    protected $_pizza;
    public function getPizza() {
        return $this->_pizza;
    }
    public function createNewPizza() {
        $this->_pizza = new Pizza ();
    }
    abstract public function buildPastry();
    abstract public function buildSauce();
    abstract public function buildGarniture();
}
 
// BuilderConcret1 - строит элементы(свойства) конструкции(чертежа) - повар печёт пиццу Hawaii со своим набором специй
class BuilderPizzaHawaii extends BuilderPizza { 
    public function buildPastry() {
        $this->_pizza->setPastry ( "normal" );
    }
    public function buildSauce() {
        $this->_pizza->setSauce ( "soft" );
    }
    public function buildGarniture() {
        $this->_pizza->setGarniture ( "jambon+ananas" );
    }
}
 
//BuilderConcret2 - строит элементы(свойства) конструкции(чертежа) - повар печёт пиццу Spicy со своим набором специй
class BuilderPizzaSpicy extends BuilderPizza {
    public function buildPastry() {
        $this->_pizza->setPastry ( "puff" );
    }
    public function buildSauce() {
        $this->_pizza->setSauce ( "hot" );
    }
    public function buildGarniture() {
        $this->_pizza->setGarniture ( "pepperoni+salami" );
    }
}
 
/////////////////////////////  Director - Управляющий класс, запускающий строительство /////////////////////////////////
// Он даёт команду строителю (в нашем случае повару) BuilderPizza, которого выбрал клиент под свои нужды, строить объект (делать пиццу A или B) 
class PizzaDirector {
    private $_builderPizza;
    public function setBuilderPizza(BuilderPizza $mp) {		// принимает заказ от клиента
        $this->_builderPizza = $mp;
    }
    public function getPizza() {					// возвращает клиенту построенный объект
        return $this->_builderPizza->getPizza();
    }
    public function constructPizza() {				// команда стрителю - строить объект
        $this->_builderPizza->createNewPizza ();
        /* эти методы согласно рефакторингу логичнее разместить в createNewPizza() класса BuilderPizza, как это сделано в примере Builder_2.php
         * потому что они работают только со свойством и методами класса BuilderPizza. Но это немного нарушит принцип поэтапного руководства
         * строительством. Думаю, здесь важнее рефакторинг, чем правила шаблона и эти методы лучше поместить туда, где им место.
         */
        $this->_builderPizza->buildPastry ();
        $this->_builderPizza->buildSauce ();
        $this->_builderPizza->buildGarniture ();
    }
}
 
/////////////////////////////// Client - исполнительный код ////////////////////////////////////////////////////////////
// Клиент вызвал директора стройки (в нашем случае директора или официанта пиццерии) 
$pizzaBuilder = new PizzaDirector();
  
// и сделал заказ построить конкретный объект (принести пиццу Hawaii)
$pizzaBuilder->setBuilderPizza( new BuilderPizzaHawaii() );

// Директор дал команду строителю - построить требуемый объект (официант дал команду повару приготовить пиццу Hawaii)
$pizzaBuilder->constructPizza();

// Директор передал готовый объект клиенту (официант принёс клиенту пиццу Hawaii)
$pizza = $pizzaBuilder->getPizza();

echo '<pre>';
print_r($pizza);

/*
Интересно сравнить приведенный код с кодом создания армии в реализации паттерна Abstract Factory, который также может использоваться для создания сложных продуктов. 
Если паттерн Abstract Factory акцентирует внимание на создании семейств некоторых объектов, то паттерн Builder подчеркивает поэтапное построение продукта. 
При этом класс Builder скрывает все подробности построения сложного продукта так, что Director ничего не знает о его составных частях.
Достоинства паттерна Builder:
    Возможность контролировать процесс создания сложного продукта.
    Возможность получения разных представлений некоторых данных.
Недостатки паттерна Builder:
    Builder-классы и создаваемый им продукт жестко связаны между собой, поэтому при внесеннии изменений в класс продукта скорее всего придется соотвествующим образом изменять и Builder-классы.
*/