========================
  PHP Стандарты кодирования
========================

В этом файле перечислены несколько стандартов, что добавление любой программист или меняющиеся
код в PHP должны следовать. Так как этот файл был добавлен в очень поздно
этап развития PHP v3.0, кодовая база не (пока) полностью
следовать ему, но он собирается в этом общем направлении. Так как мы в настоящее время
хорошо в версии 5 релизы, многие разделы были перекодировано использовать
эти правила.

Реализация код
-------------------

0. Документировать код в исходных файлах и руководстве. [TM]

1. Функции, которые даются ссылки на ресурсы не должна освободить их

Например, `` функция внутр почты (символ * к, символ * от) `` не должны бесплатно
и / или с.
Исключения:

- Обозначены поведение функции в освобождает этот ресурс. Например EFree ()

- Функция дается логическое аргумент, который управляет или нет
  функция может освободить свои аргументы (если это правда - функция должна освободить его
  аргументы, если ложно - оно не должно)

- Низкий уровень подпрограммы синтаксического анализа, которые тесно интегрированы с маркером
  Кэш и бизон код копирования накладных расходов минимум памяти.

2. Функции, которые тесно интегрированы с другими функциями в рамках
    тот же модуль, и полагаться друг на друга нетривиального поведения, должны быть
    документально как таковой и объявил "статическими". Они должны избежать, если
    возможно.

3. Используйте определения и макросы, когда это возможно, так что константы имеют
    значимые имена и можно легко манипулировать. Единственными исключениями
    из этого правила являются 0 и 1, при использовании в качестве ложь и истина (соответственно).
    Любое другое использование числовой константы иметь различные виды
    или действия должно быть сделано через # определить.

4. При написании функций, позволяющих работать со строками, обязательно помнить
    что РНР имеет свойство длины каждой строки, и что он
    не следует рассчитывать с STRLEN (). Напишите ваши функции в таких
    способ так, чтобы они воспользоваться имущества длины, как
    для повышения эффективности и для них, чтобы быть безопасна в бинарном режиме.
    Функции, которые изменяют строк и получить свои новые длины в то время как
    Поступая таким образом, должны вернуть эту новую длину, так что это не должно быть
    пересчитывается с STRLEN () (например php_addslashes ())

5. ЗАПРЕЩАЕТСЯ ИСПОЛЬЗОВАТЬ strncat (). Если вы абсолютно уверены, что знаете, что вы делаете,
    проверить его странице снова, и только тогда, рассмотреть возможность использования его, и даже тогда,
    попробуйте избегать его.

6. Используйте `` php_ * `` макросы в источнике PHP и `` Zend_ * `` макросы в Zend
    часть источника. Хотя `` php_ * `` макроса в основном псевдоним
    `` Zend_ * `` макросы это дает лучшее понимание о том, какие макроса
    вы звоните.

7. Когда комментирования кода, используя # Если заявление, НЕ используйте только 0. Вместо
    использовать "<git имя пользователя here> _0". Например, # если FOO_0, где FOO это ваш
    мерзавец пользователь Foo. Это позволяет легче отслеживать причины код был комментарий,
    особенно в комплекте библиотек.

8. Не определять функции, которые не доступны. Например, если
    Отсутствует библиотека функцию, не определяют PHP версии
    функция, а не поднимают во время выполнения ошибку о функции не
    существующие. Конечные пользователи должны использовать function_exists () для проверки
    Существование функции

9. Предпочитаю emalloc (), EFree (), estrdup (), и т.д., чтобы их стандартной библиотеки C
    коллегами. Эти функции реализовать внутренний "Безопасность-сеть"
    механизм, обеспечивающий процесс отключения любого unfreed памяти на
    конец запроса. Они также предоставляют полезную распределение и переполнение
    Информация во время работы в режиме отладки.

    Почти во всех случаях, память возвращается к двигателю должны быть выделены
    с использованием emalloc ().

    Использование таНос () должно быть ограничено случаями, когда сторонних
    библиотека может нужно контролировать или освободить память, или когда память в
    вопрос требует, чтобы выжить между несколькими запросами.

Пользовательские функции / методы Соглашения по именованию
------------------

1. Имена функций для функций пользовательского уровня должны быть заключены с в
    PHP_FUNCTION () макрос. Они должны быть в нижнем регистре, со словами
    подчеркивают разделителями, с тщательностью, чтобы минимизировать количество письмо.
    Сокращения не должны использоваться, когда они значительно уменьшить
    читаемость самого имени функции ::

    Хорошо:
    'Mcrypt_enc_self_test'
    'mysql_list_fields'

    Хорошо:
    'mcrypt_module_get_algo_supported_key_sizes'
    (Может быть 'mcrypt_mod_get_algo_sup_key_sizes'?)
    'Get_html_translation_table'
    (Может быть "html_get_trans_table '?)

    Плохо:
    'Hw_GetObjectByQueryCollObj'
    'Pg_setclientencoding'
    'Jf_n_s_i'

2. Если они являются частью "родительской набор» функций, что родитель должен
    быть включены в имя функции пользователя и должны быть четко связаны
    в программу родительского или функции семьи. Это должно быть в форме
    из `` parent_ * `` ::

    Семейство функций 'Foo', например:
    Хорошо:
    'Foo_select_bar'
    'Foo_insert_baz'
    'Foo_delete_baz'

    Плохо:
    'Fooselect_bar'
    'Fooinsertbaz'
    'Delete_foo_baz'

3. Имена функций, используемые пользовательских функций должны иметь префикс
    с `` _php_ ``, и следует слово или подчеркивания запятыми список
    слова, строчными буквами, который описывает функцию. Если это применимо,
    они должны быть объявлены "статическими".

4. Имена переменных должны быть значимыми. Одни названия письмо переменные должны быть
    избежать, для мест, где переменная не имеет реального смысла или исключением
    тривиальный смысл (например, для (я = 0; г <100; я + +) ...).

5. Имена переменных должны быть в нижнем регистре. Использование подчеркивания для разделения
    между словами.

6. Имена методов следовать "studlyCaps '(также называемые" ухабистой случае "
    или "верблюд шапки") именования, с тщательностью, чтобы минимизировать
    Письмо количество. Начальная буква имени в нижнем регистре, и каждый
    Письмо, которое начинает новую «слово» капитализируются ::

    Хорошо:
    "Подключения () '
    'GetData ()'
    'BuildSomeWidget ()'

    Плохо:
    'Get_data ()'
    'Buildsomewidget'
    'GETI ()'

7. Классы следует уделять описательные имена. Избегайте использования аббревиатур, где это
    возможно. Каждое слово в имени класса следует начинать с заглавной буквы,
    без подчеркивания разделителями (верблюжьей начинающиеся с большой буквы).
    Имя класса должно начинаться с именем «исходных набора» (например,
    имя расширения) ::

    Хорошо:
    "Curl"
    'FooBar'

    Плохо:
    'Foobar'
    'Foo_bar'

Служба внутреннего именования Convensions
----------------------

1. Функции, которые являются частью внешнего API должен быть назван
    'Php_modulename_function ()', чтобы избежать столкновения символов. Они должны быть в
    в нижнем регистре, со словами подчеркивания разделителями. Открытые API должны быть определены
    в 'php_modulename.h'.

    PHPAPI символ * php_session_create_id (PS_CREATE_SID_ARGS);

    Неэкспонированную функциональный модуль должен быть статическим и не должны быть определены в
    'Php_modulename.h'.

    статическая внутр php_session_destroy (TSRMLS_D)

2. Основной исходный файл модуля должен быть назван 'modulename.c'.

3. Заголовочный файл, который используется другими источниками должны быть названы 'php_modulename.h'.


Синтаксис и отступы
----------------------

1. Никогда не используйте комментарии + + стиле C (то есть / / комментарий). Всегда используйте C-стиль
    комментарии вместо. PHP написан на С, и направлена ??на составление
    под любым компилятором совместимой ANSI-C. Хотя многие компиляторы
    принять C + комментарии +-типа в С-код, вы должны убедиться, что ваш
    код будет компилировать с других компиляторов, а также.
    Единственным исключением из этого правила является код, который Win32 конкретных,
    так как порт Win32, MS-Visual C + + конкретным, и этот компилятор
    , как известно, принимают C + комментарии +-типа в С-код.

2. Используйте K & R-Style. Конечно, мы не можем и не хотим
    заставить никого использовать стиль он или она не используется, но,
    по крайней мере, при написании кода, который идет в ядро
    из PHP или одного из его стандартных модулей, пожалуйста, поддерживать K & R
    стиль. Это относится к примерно всему, начиная с
    отступов и комментарий стили и до объявления функции
    Синтаксис. Также см. Indentstyle.

    Indentstyle: http://www.catb.org/ ~ ЭПР / жаргон / HTML / я / отступ-style.html

3. Будьте щедры с пробелами и скобки. Храните одну пустую строку между
    переменного сечения декларации и заявления в блоке, а также
    между логические группы отчетности в блоке. Поддерживать по крайней мере один пустой
    линия между двумя функциями, предпочтительно двух. Всегда предпочитаю ::

    если (Foo) {
        бар;
    }

    в:

    если (Foo) бар;

4. Когда отступов, используйте символ табуляции. Вкладка как ожидается, представляют
    четыре пространства. Важно сохранять последовательность в соглашении об эмиссии так
    что определения, комментарии, и управляющие структуры выстраиваются правильно.

5. Препроцессора отчетность (#, если и такое) должна начинаться с первой колонки. К
    отступ директивы препроцессора вы должны поставить # в начале
    линии, а затем любое число пробелов.

Тестирование
-------

1. Расширения должны быть хорошо проверены с помощью *. PHPT тесты. Читайте о том, что
    в README.TESTING.

Документация и складной Крючки
-------------------------------

Для того, чтобы убедиться, что онлайн-документация остается в соответствии с
код, каждая функция пользовательского уровня должны иметь свою функцию на уровне пользователя
Прототип перед ним вместе с кратким описанием одной строки о том, что
функция делает. Это будет выглядеть следующим образом ::

  / * {{{Прото внутр абс (десятичного числа)
     Возвращает абсолютное значение числа * /
  PHP_FUNCTION (абс)
  {
     ...
  }
  / *}}} * /

В {{{символы являются символами складывающиеся по умолчанию для режима складывания в
Emacs и Vim (набор FDM = маркер). Складной очень полезно при работе с
большие файлы, потому что вы можете пролистать файл быстро и просто развернуть
функция вы хотите работать. }}} В конце каждой функции знаков
конец лоно, и должно быть на отдельной строке.

"Прото" ключевое слово есть только помощником для Doc / genfuncsummary сценария
который генерирует полный резюме функцию. Имея это ключевое слово перед
прототипы функций позволяет нам поставить складки в другом месте в коде без
Мессинг итоговую функцию.

Дополнительные аргументы записываются так ::

  / * {{{Прото объект imap_header (внутр stream_id, внутр msg_no [, внутр from_length [, внутр subject_length [, строка default_host]]])
     Возвращает объект заголовка с учетом заданных параметров * /

И да, пожалуйста, имейте прототип в одной строке, даже если это линия
имеет массовый характер.

Новые и экспериментальные функции
-----------------------------------
Чтобы уменьшить проблемы, обычно связанные с первого общественности
реализация нового набора функций, было высказано предположение,
что первая реализация включить файл с надписью «экспериментальное»
в каталоге функции, и что функции следовать
стандартный префикс конвенций во время их первоначального внедрения.

Файл помечены «экспериментальное» должны включать следующее
информация ::

  Любая информация авторинга (известные ошибки, будущие направления модуля).
  Текущая статус отмечает, которые не могут быть неподходящими для Git комментариев.

В целом новые возможности не должны пойти в PECL или экспериментальных отраслей пока
Есть конкретные причины непосредственно добавив его в основного дистрибутива.

Псевдонимы & Наследие Документация
-----------------------------------
Вы также можете иметь некоторые устаревшие псевдонимы с рядом дублировать
имена, например, somedb_select_result и somedb_selectresult. Для
документирования, они будут задокументированы только наиболее
Нынешнее название, с псевдонимами, перечисленных в документации
материнская функция. Для удобства сопоставления пользовательских функций с
совершенно разные имена, что псевдоним к той же функции (например,
highlight_file и show_source), будут отдельно документально. 
прото все равно должны быть включены, описывая которые функционируют является псевдонимом.

Обратная совместимость функции и названия должны быть сохранены до тех пор,
как код может быть достаточно иметь в составе код. Посмотреть
/ PHPDoc / README для получения дополнительной информации о документации.