<?php
/*
 1.Допускается переопределение свойства в классе наследнике.
 2.Переопределение модификатора доступа метода или свойства (по аналогии с наследованием от abstract class):
	- нельзя задавать более закрытый уровень доступа, чем в классе родителе (напр. protected когда в родителе public)
	- можно задавать тот же уровень доступа или более открытый, чем в классе родителе (напр. public когда в родителе protected)		
 3.Из Java по аналогии:
 Наследование свойства или метода - это фактически автоматическое переопределение свойства или метода в наследнике c кодом родителя.
 И если мы сами принудительно не переопределяем свойства или метод в наследнике, то компилятор это делает за нас. 
 Т.е. наследник работает не с унаследованными свойством или методом родителя, 
 а со свойством или методом, которые были автоматически переопределены из класса родителя в классе наследнике.
 И обращаясь к методу напр. getName(), который был унаследован, мы обращаемся к методу getName() в наследнике, который был переопределён компилятором, но визуально в коде это не показывается.
 4. Не путать понятия переопределение свойства или метода (Override) и перезагрузку (Overload) метода или функции.
	В PHP Overload не работает (в отличие от Java), поэтому многие php-шники и смешивают эти два понятия.	 
	Overload - это создание нового метода или функции с тем же названием, но с раширением его параметров: 
		setName($name) и setName($name, $age) - существуют независимо. 
	Override - это замещение существующего метода или свойства (унаследованного) новым с тем же названием и тем же количеством параметров:
		setName($name) родителя заменяется на setName($name) в наследнике.
*/

class User {
	public $name = 'Alex';
	protected $age = 'Age';	
	protected function getName(){ return $this->name; }	
}

class SuperUser extends User {
	public $name = 'John';			// переопределяем свойство
	//private $age = 'Age';			// переопределяем свойство и доступ на более закрытый - Fatal error: Access level to SuperUser::$age must be protected (as in class User) or weaker
	
	// переопределение доступа на более открытый
	public function getName() { return $this->name; }	
}

// Наследование - это автоматическое переопределение с кодом родителя:
class MegaUser extends User { 
	// Принудительно непереопределённые свойства и методы будут компилятором переопределыны c кодом родителя:
	// public $name = 'Alex';
	// protected $age = 'Age';	
	// protected function getName(){ return $this->name; }		
}


$user = new User();
$superUser = new SuperUser();

// переопределение свойств и методов
echo 'user: '.$user->name.'<br>';
echo 'superUser: '.$superUser->name.'<br>';
echo 'superUser->getName(): '.$superUser->getName().'<br>';

// наследование свойства
$megaUser = new MegaUser();
$megaUser->name = 'Kate';
echo 'user: '.$user->name.'<br>';
echo 'megUser: '.$megaUser->name.'<br>';

?>