<?php
// именование классов с большой буквы
/***************************************************************************************************
 * Трейты - это наподобие инклюдников. С них нельзя делать екземпляры. 
 * В них могут быть свойства и методы, которые передаются классу, в который подключается трейт. При
 * этом наследники получают тоже свойства и методы используемого родителем трейта.
 * Трейты могут вкладываться друг в друга и иметь абстрактные методы.
 * Фактически трейты - это оболочка для облегчения кода классов с большими методами и большим количеством свойств.
 * И тогда свойства класса можно вынести в отдельный трейт, а методы - в отдельные.
 ***************************************************************************************************/
trait Property
{
    private $login = 'algerd';
    private $password = '987654321';
}
trait LoginPass
{
    public function getLogin(){
        echo $this->login;
    }
    private function getPassword(){
        echo $this->password;
    }
}
    
/***************************************************************************************************
 * Интерфейс - это абстрактный класс, в котором могут быть только!!! абстрактные методы и константы 
 * Фактически Интерфейс - это набросок-наброска или чистый эскиз без реализации
 * Допускается наследование от нескольких интерфейсов, наследники перечисляются через запятую
 ***************************************************************************************************/
interface InterfaceEmail{
    const INTERF = 'InterfaceUser'; // константы не надо переопределять и их вызывают по аналогии с обычными классами
    // методы интерфейса только публичные.
    public function getEmail();    
}
interface InterfaceAge{
    public function getAge();       
}
 
/***************************************************************************************************
 * Создаём абстрактный класс - набросок, эскиз для классов его наследников, в которых должны быть переопределены указанные абстрактные методы.
 * От него нельзя создать его экземпляр.
 ***************************************************************************************************/
abstract class AbstractUser
{ 
    // В абстрактном классе можно прописывать свойства и методы как в обычных классах и эти они будут унаследованы классами наследниками
    public $a = 10;
    public function getA(){
        return $this->a;
    }  
    // декларирование абстрактного метода-наброска для классов наследников этого абстрактного класса
    // он не имеет тела с кодом и он должен быть переопределён в классе наследнике
    // приват-доступ и тип аргументов должен быть в точности повторён в наследнике
    abstract public function getEmail();
    abstract public function getAge();    
}

/***************************************************************************************************/
// в классе-наследнике абстрактного класса надо переопределять абстрактные!!! методы абстрактного класса
// наследование от нескольких интерфейсов, наследники перечисляются через запятую
class User extends AbstractUser implements InterfaceEmail, InterfaceAge
{ 
    // подключаем трейты
    // переопределяем доступ к методу getPassword с private на public
    use Property, LoginPass {
        getPassword as public;        
    }
    
    public    $name;       // свойство, видимо отовсюду
    protected $_age = 5;   // видно только изнутри наследников и этого класса. Задано умолчание 5
    private   $_email;     // видно только изнутри этого класса. private и protected обозначаем _name
    public static $stat = 0; // статическое свойство класса. Оно одно и принадлежит классу, а не объектам.  
    const     DB = 'User'; // задаём константу. Её нельзя переопределять нигде
    
    // объявление конструктора класса, который инициализирует свойства объекта
    public function __construct($n, $a, $e){
        // обращение к свойствам внутри класса осуществляется через $this->
        $this->name = $n;
        $this->age = $a;
        $this->_email = $e;
        // подсчёт объектов - каждый вызов класса(при создании объекта) приводит к увеличению статич. свойства на 1
        // доступ к статич. свойствам с класса и наследников через ключ self::
        ++self::$stat;
    }
    //Объявление метода, вызываемого при удалении объекта, он не может иметь аргументов. Порядок удаления объектов не определён 
    public function __destruct(){
        // обращение изнутри класса к константам производится через ключ self:: (из наследников к константе родителя тоже через self::
        echo '<br>Объект класса '.self::DB.' удалён';
    }  
    // Объявление метода, вызываемого при копировании(клонировании) объекта, он не может иметь аргументов 
    // Он всегда private
    function __clone(){
        echo 'Объект клонирован<br>';
    }
    // Объявление стандартного метода класса. Они могут быть public, protected или private по аналогии со свойствами
    // Таким образом описывают методы получения доступа к закрытым свойствам (protected или private). Именование getName()
    public function getEmail(){
        return $this->_email;
    }
    // Объвляем финальный метод, который нельзя переопределить в классах наследниках
    final public function getName(){
        return $this->name;
    }   
    // переопределяем абстрактный метод родителя
    public function getAge(){}
    
    // объявляем статический метод - к нему будет доступ без необходимости создания объектов, это метод класса, а не объекта.
    // Т.к. это метод класса, а не объектов, то он не может использовать свойства объектов. Т.е. он использует только статические свойства и константы
    // доступ к нему изнутри классов и наследников через self:: или NameClass::
    public static function getClassName(){
        echo 'Это класс '.self::DB.'<br>';
        echo 'Число созданных объектов: '.self::$stat.'<br>';
    }
}

/***************************************************************************************************/
// Создаём класс-наследник класса User. Недопустимо множественное наследование (от нескольких классов).
// Ему доступны public и protected свойства и методы класса-родителя User
// Объявляем класс финальным - его нельзя унаследовать 
final class SuperUser extends User
{
    public $role;   // свойство класса SuperUser, которое не будет видно из класса родителя User
        
    // Объявляем(переопределяем) конструктор класса SuperUser и инициализируем свойства
    // Если не переопределять конструктор, то будет действовать конструктор родителя 
    public function __construct($n, $a, $e, $r){
        // вызываем конструктор родителя
        // !!! ключ для вызова методов родителя parent::
        parent::__construct($n, $a, $e);
        $this->role = $r;
        // обращение к константе класса-родителя. Можно и напрямую User::DB
        echo 'Создан объект родителя '.self::DB.'<br>';
    }   
    // Переопределяем метод getEmail() класса родителя User. Объекты этого класса будут использовать этот метода, а не родителя
    public function getEmail(){
        echo 'SuperUser: ';
        // вызываем метод родителя User, который был переопределён в SuperUser
        echo parent::getEmail(); // 
    }
}

/***************************************************************************************************/
// Класс без конструктора можно объявлять без скобок $user1 = new User, но не надо, потому что при создании конструктора прийдётся править везде и скобки
$user1 = new stdClass;

$user1 = new User('Alex', '30', 'alex@mail.ru');// создаём объект $user1 класса User
echo 'имя: '.$user1->name.'<br>';               // вызов public свойства объекта $user1  
echo 'email: '.$user1->getEmail().'<br>';       // вызов public метода объекта $user1

$user2 = clone $user1;  // копирование(клонирование) объекта $user1 вместе с его свойствами, одновременно вызовется метод __сlone() класса User
echo $user2->name.'<br>';      // вызов public свойства объекта $user2

$user3 = new SuperUser('John', '25', 'aaa@.mail.ru', 'Admin');
$user3->getEmail();       // вызов переопределённого public метода объекта $user3

echo '<br>Это вызов константы:'.User::DB.'<br>'; // обращение к константе класса снаружи. Также можно обращаться и изнутри других классов-ненаследников
echo 'Число объектов: '.User::$stat.'<br>'; // обращение к статич. свойству класса. Также можно обращаться и изнутри других классов-ненаследников
User::getClassName(); // вызов статического метода класса User

// динамический вызов статического метода
$class = 'User';
$method = 'getClassName';
$class::$method(); 
echo '<br>';

// вызов методов, прописанных из трейтов
$user1->getLogin();
$user1->getPassword();


?>

