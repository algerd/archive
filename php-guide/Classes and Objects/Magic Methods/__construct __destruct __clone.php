<?php
/*
	Конструктор:
	void __construct ([ mixed $args [, $... ]] )

Классы, в которых объявлен метод-констуктор, будут вызывать этот метод при каждом создании нового объекта, 
так что это может оказаться полезным, например, для инициализации какого-либо состояния объекта перед его использованием.

Замечание: Конструкторы в классах-родителях не вызываются автоматически, если класс-потомок определяет собственный конструктор. 
		Чтобы вызвать конструктор, объявленный в родительском классе, следует обратиться к методу parent::__construct() внутри конструктора класса-потомка. 
		Если в классе-потомке не определен конструктор, то он может наследоваться от родительского класса как обычный метод (если он не определен как приватный). 

Если конструктор объявлен private, то создать объект такого класса не получится. 
Для protected удастся создать объект только в наследниках.

	Деструктор:
	void __destruct ( void )	// аргументы не передаются

Деструктор будет вызван при освобождении всех ссылок на определенный объект (удаление объекта) или при завершении скрипта (порядок выполнения деструкторов не гарантируется). 
Как и в случае с конструкторами, деструкторы, объявленные в родительском классе, не будут вызваны автоматически. 
Для вызова деструктора, объявленном в классе-родителе, следует обратиться к методу parent::__destruct() в теле деструктора-потомка. 
Также класс-потомок может унаследовать деструктор из родительского класса, если он не определен в нем. 
Не рекомендуется в деструкторе прописывать какие-либо важные действия (напр. над БД), а описывать их и вызывать явно из дополнительных методов,
чтобы иметь полный контроль,а не доверяться магич. методу. 
 
	Клонирование объектов
	void __clone ( void )		// аргументы не передаются
 
Копия объекта создается с использованием ключевого слова clone (который вызывает метод __clone() объекта, если это возможно). 
Вызов метода __clone() не может быть осуществлён непосредственно ($obj->_clone()). 
Если у клонируемого объекта есть свойства - объекты, то они не будут клонированы, а будет скопирована только ссылка на них.
Чтобы клонировать объект полностью, то надо прописывать явно в __clone() и клонирование его свойств-объектов.
Если требуется запретить клонирование - объявить private __clone()
 
*/	

class SuperUser{
	public $role = 'admin';	
}

class UserList {
	public $superuser;	// объект
	
	public function __construct(SuperUser $obj) {
		echo 'Создание объекта класса '.__CLASS__.'<br>';
		$this->superuser = $obj;
	}	
	public function __clone(){
		echo 'Клонирование объекта класса '.__CLASS__.'<br>';
        // клонирование свойства-объекта - закомментирован, чтобы было понятно рассуждение ниже
        //$this->superuser = clone $this->superuser;
	}		
	public function __destruct() {
       echo "Уничтожается объект класса ".__CLASS__.'<br>';
	}
}

// User унаследует все методы класса UserList
class User extends UserList {}


$suser = new SuperUser(); // т.к. конструктора в классе SuperUser нет, то скобки можно опустить, но так лучше не делать!
$user1 = new User($suser); 

$user2 = clone $user1;
// закомментируем/раскомментируем код в методе __clone()
echo 'Свойство клонированного объкта: '.$user2->superuser->role.'<br>';
$suser->role = 'guest';	// меняем свойство объекта $suser
echo 'Свойство клонированного объкта поменялось/не поменялось: '.$user2->superuser->role.'<br>';

?>